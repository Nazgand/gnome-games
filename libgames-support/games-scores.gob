/* -*- mode:C -*-

   games-scores.gob

   Copyright 2005 Callum McKenzie

   This library is free software; you can redistribute it and'or modify
   it under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Authors:   Callum McKenzie <callum@physics.otago.ac.nz> */

requires 2.0.0

/* FIXME: Document */
%h{

  /* GamesScore and GamesScoresStyle should be kept in sync. */
  typedef union {
    guint32 plain;
    gdouble time_double; /* minutes.seconds */
  } GamesScore;

  typedef enum {
    GAMES_SCORES_STYLE_PLAIN,
    GAMES_SCORES_STYLE_TIME,
  } GamesScoresStyle;

  typedef struct {
    gchar *key;  /* A unique identifier (warning: this is used to generate the
		  * scores file name, so it should match the old domains) */
    gchar *name; /* A human-readable description. */
  } GamesScoresCategory;

  /* All elements get copied so the creator stays the owner. */
  typedef struct {
    GamesScoresCategory ** categories; /* NULL terminated! */
    gchar * deflt; /* The key of the default category. */
    gchar * filename;
    GamesScoresStyle style;
  } GamesScoresDescription;
%}

%alltop{
/* Games Scores Dialog - Display high scores
 *
 * Copyright (c) 2005 by Callum McKenzie
 *
 */

%}

%a{
#include <gtk/gtk.h>
%}

%{
#include <config.h>

#include <gnome.h>

#include <math.h>
#include <fcntl.h>
#include <unistd.h>

#include <games-scores-dialog.h>

  /* We want GamesScoresCategory to be a plain structure so it can easily
   * be initialised at compile time (to make writing a GamesScoresDescription
   * easy). However we do need some common methods. These functions
   * are here to give us our "pseudo-object". */

  void games_scores_category_free (GamesScoresCategory *cat) {
    g_free (cat->key);
    g_free (cat->name);
    g_free (cat);
  }

  GamesScoresCategory *games_scores_category_dup (GamesScoresCategory *orig) {
    GamesScoresCategory *newcat;
    
    newcat = g_new (GamesScoresCategory, 1);
    newcat->key = g_strdup (orig->key);
    newcat->name = g_strdup (orig->name);

    return newcat;
  }

%}

/* FIXME: Static games_score_init function to initialise the setgid stuff. */
/* FIXME: This is actually an argument for a helper-app since this function
 * won't know what files we are after until _new is called. */

class Games:Scores from G:Object {

  private GHashTable *categories;
  private gchar *currentcat;
  private gchar *defcat;
  private gboolean last_score_significant;
  private gint last_score_position;
  private GamesScoresStyle style;
  private gchar *filename;
  private int scoresfd;
  /* private struct flock lock; */
  private GtkWidget *dialog;

  /** 
   * new:
   * @description: A GamesScoresDescription structure with the information
   *               about this games scoring system. 
   *
   * Create an object to handle a set of scores. Normally you will make one
   * global object. Creating and destroying these objects is inefficient. 
   * Using multipl objects referring to the same set of scores at the same
   * time should work but is unnecessary liable to be buggy.
   */
  public GObject * new (GamesScoresDescription * description) {
    GamesScores *self = GET_NEW;
    GamesScoresCategory *cats;
    GamesScoresCategory *dupcat;

    /* FIXME: Input sanity checks. */

    cats = self->_priv->categories;
    self->_priv->categories = g_hash_table_new_full (g_str_hash, g_str_equal,
						     g_free, 
						     games_scores_category_free);
    while (cats) {
      dupcat = games_scores_category_dup (cats);

      g_hash_table_insert (self->_priv->categories, 
				  g_strdup (cats->key),
				  dupcat);
      cats++;
    }

    self->_priv->defcat = g_strdup (description->deflt);
    self->_priv->currentcat = g_strdup (self->_priv->defcat);
    /* FIXME: Do some sanity checks on the default and the like. */
    
    self->_priv->style = description->style;

    /* Find and open the file */
    self->_priv->filename = g_build_filename (SCORESDIR,
					      description->filename, NULL);

    self->_priv->scoresfd = open (self->_priv->filename, O_RDWR);
    /* FIXME: We don't have a finaliser yet to close the fd again. */


    /*    self->_priv->lock->l_type = F_RDLCK;
    self->_priv->l_whence = SEEK_SET;
    self->_priv->l_start = 0; 
    self->_priv->l_len = 0; *//* All of it */

    return self;
  }

  /**
   * set_category:
   * @scores: A scores object.
   * @category: A string identifying the category to use (the key in
   *            the GamesScoresCategory structure).
   *
   * This function sets the scores category to use. e.g. whether we are playing
   * on hard, medium or easy. It should be used at the time that the game
   * itself switches between difficulty levels. The category determines where
   * scores are to be stored and what the default score display is when the
   * dialog is requested.
   *
   **/
  public void set_category (Games:Scores *self, gchar *category) {

    g_return_if_fail (self != NULL);

    if (category == NULL)
      category = self->_priv->defcat;

    if (self->_priv->currentcat)
      g_free (self->_priv->currentcat);

    self->_priv->currentcat = g_strdup (category);
      
    if (self->_priv->dialog != NULL)
      games_scores_dialog_set_category (GAMES_SCORES_DIALOG (self->_priv->dialog),
					category);

    /* FIXME: Check validity of category (Null, the same as current, 
     * is actually a category) then just set it in the structure. */
  }

  /**
   * add_score:
   * @scores: A scores object.
   * @score: A GamesScore, please use the macros to convert a score to the
   *         gpointer format.
   *
   * Add a score to the set of scores. Retention of anything but the
   * top-ten scores is undefined. It returns a boolean indicating whether
   * the score is a top-ten one or not.
   **/
  /* FIXME: Write the above-mentioned macros. */
  public gboolean add_score (Games:Score *self, GamesScore score) {
    /* FIXME: Fill in. */
    return FALSE;
  }

  private void set_dialog_categories (gchar *key, 
					   GamesScoresCategory *cat,
					   GamesScoresDialog *dialog)
    {
      games_scores_dialog_add_category (dialog, key, cat->name);
    }

  /**
   * show:
   * @scores: A scores object.
   * @hilight: Whether or not to hilight the last high score set (if
   *           it was a top-ten score).
   *
   * The basic function for showing a high scores dialog. All the details
   * are taken care of for you, you merely have to decide on whether this
   * is a user interested in the historic high scores or if it is a report 
   * on the last game played.
   */
  public void show (Games:Scores *self, gboolean hilight) {
    GtkWidget *dialog;
    GamesScoresCategory *cats;
    
    if (self->_priv->dialog == NULL) {
      /* FIXME: The title is a problem. */
      dialog = games_scores_dialog_new (NULL, "This title is wrong");

      g_hash_table_foreach (self->_priv->categories, 
			    (GHFunc) games_scores_set_dialog_categories,
			    dialog);

      /* FIXME: Also fill in the buttons and the message and the like. 
       * This may have to be done below. */

      games_scores_dialog_set_category (GAMES_SCORES_DIALOG (dialog),
					self->_priv->currentcat);

      self->_priv->dialog = dialog;
    } else {
      /* FIXME: Probably should move this beyond the code that
       * sets the hilight and the like. */
      gtk_window_present (GTK_WINDOW (self->_priv->dialog));
    }
    
    if (hilight) {
      games_scores_dialog_set_hilight (GAMES_SCORES_DIALOG (self->_priv->dialog),
				       self->_priv->last_score_position);
    }

  }

  init (self) {
    /* Most of the work is done in the _new method. */

    self->_priv->last_score_significant = FALSE;
    self->_priv->last_score_position = -1; /* FIXME: = 0? */

    self->_priv->dialog = NULL;
  }
}
