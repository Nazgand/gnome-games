/* -*- mode: C -*-

   games-files.c
   Copyright 2004, 2005 Callum McKenzie

   This library is free software; you can redistribute it and'or modify
   it under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Authors:   Callum McKenzie <callum@physics.otago.ac.nz> */

requires 2.0.0

/* FIXME: This enum should be documented. */

%h{
  #include "games-score.h" /* For GamesScoreStyle. */
  #include "games-scores.h"

  typedef enum {
    GAMES_SCORES_CLOSE_BUTTON = 1,
    GAMES_SCORES_NEW_GAME_BUTTON = 2,	
    GAMES_SCORES_UNDO_BUTTON = 4,
    GAMES_SCORES_QUIT_BUTTON = 8,
  } GamesScoresButtons;

%}

%alltop{
/* Games Scores Dialog - Display high scores
 *
 * Copyright (c) 2004, 2005 by Callum McKenzie
 *
 */

%}

%a{
#include <glib/gi18n.h>
#include <gtk/gtk.h>
%}

%{

#include <config.h>

#include <gnome.h>

#include <math.h>
%}

/* FIXME: There is basically no range checking. */

class Games:Scores:Dialog from Gtk:Dialog {

  private GtkWidget *message;
  private GtkWidget *hdiv;
  private GtkWidget *combo;
  private GtkWidget *label;
  private GtkWidget *catbar;
  private GtkListStore *list;
  private GtkTreeView *treeview;
  private GtkCellRenderer *namerenderer;
  private GtkTreeViewColumn *column;
  private GtkTreeViewColumn *namecolumn;
  private GamesScores *scores destroywith g_object_unref;
  private GHashTable *categories destroywith g_hash_table_destroy;
  private GHashTable *catindices destroywith g_hash_table_destroy;
  private gint catcounter;
  private gint hilight;
  private gboolean preservehilight;
  private gulong cursor_handler_id;

  /* FIXME: This should be a property. */
  private gint style;

  private void load_categories (GamesScoresCategory *cat, 
				GamesScoresDialog *self) {
    /* Note the Q_ here, this is so we can use context tags on similar
     * names. (Medium is one that can cause trouble for translators 
     * in different contexts.) */
    games_scores_dialog_add_category (self, cat->key, Q_(cat->name));
  }

  /**
   * new:
   * @domain: the scores domain to use, usually the application name
   * @title: the title for the dialog
   * 
   * Creates a new high scores dialog. Use gtk_dialog_run and 
   * gtk_widget_destroy to manage it.
   *
   * Returns: a new widget
   *
   **/
  public GtkWidget * new (GamesScores *scores, const gchar *title) {
    GamesScoresDialog *dialog = GET_NEW;

    dialog->_priv->scores = g_object_ref (scores);
    games_scores_dialog_set_style (dialog, games_scores_get_style (scores));
    dialog->_priv->preservehilight = FALSE;

    gtk_window_set_title (GTK_WINDOW (dialog), title);

    games_scores_category_foreach (scores, 
				   (GamesScoresCategoryForeachFunc) games_scores_dialog_load_categories, dialog);

    if (dialog->_priv->catcounter <= 1) {
      gtk_widget_hide (dialog->_priv->catbar);
    }

    return (GtkWidget *)dialog;
  }

  private
  void name_edited (GtkCellRendererText *cell, gchar *path,
		    gchar *new_text, GamesScoresDialog *self)
  {
    GtkTreeIter iter;

    gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL (self->_priv->list), 
					 &iter, path);
    gtk_list_store_set (self->_priv->list, &iter, 0, new_text, -1);

    games_scores_update_score (self->_priv->scores, new_text);
  }

  /* Prevent editing of any cell but the ones we set. */
  private
  void cursor_changed (GtkTreeView *treeview, GamesScoresDialog *self)
  {
    g_object_set (self->_priv->namerenderer, "editable", FALSE, NULL);
  }    

  private
  void set_hilight_private (Games:Scores:Dialog *self) {
    GtkTreePath *path;
    GtkTreeSelection *selection;

    if (self->_priv->hilight == 0) {
      g_object_set (self->_priv->namerenderer, "editable", FALSE, NULL);
      return;
    }
    
    /* Temporarily disable the code that prevents editing when the
     * cursor changes position. */
    g_signal_handler_block (self->_priv->treeview, 
			    self->_priv->cursor_handler_id); 
    g_object_set (self->_priv->namerenderer, "editable", TRUE, NULL);
    selection = gtk_tree_view_get_selection (self->_priv->treeview);
    path = gtk_tree_path_new_from_indices (self->_priv->hilight - 1, -1);
    gtk_tree_selection_select_path (selection, path);
    gtk_tree_view_set_cursor (self->_priv->treeview, path, 
			      self->_priv->namecolumn, TRUE);
    g_signal_handler_unblock (self->_priv->treeview, 
			      self->_priv->cursor_handler_id); 
    g_free (path);
  }

  private
  void redraw (GamesScoresDialog *self) {
    GtkTreeIter iter;
    gchar *name;
    gint score;
    gchar *ss;
    gdouble dscore;
    GList *scorelist;

    gtk_list_store_clear (self->_priv->list);

    scorelist = games_scores_get (self->_priv->scores);

    while (scorelist) {
      name = ((GamesScore *)scorelist->data)->name;
      switch (self->_priv->style) {
      case GAMES_SCORES_STYLE_TIME_ASCENDING:
      case GAMES_SCORES_STYLE_TIME_DESCENDING:
	dscore = ((GamesScore *)scorelist->data)->value.time_double;
	score = rint (100*(dscore));
	/* Translators: this is for a minutes, seconds time display. */
	ss = g_strdup_printf (_("%dm %ds"), score/100, score%100);
	break; 
      case GAMES_SCORES_STYLE_PLAIN_ASCENDING:
      case GAMES_SCORES_STYLE_PLAIN_DESCENDING:
      default:
	score = ((GamesScore *)scorelist->data)->value.plain;
	ss = g_strdup_printf ("%d", score);
      }
      gtk_list_store_append (self->_priv->list, &iter);
      gtk_list_store_set (self->_priv->list, &iter, 0, name, 1, ss, -1);
      g_free (ss);
      scorelist = g_list_next (scorelist);
    }
      
    games_scores_dialog_set_hilight_private (self);
  }

  private 
  void change_category (Gtk:Combo:Box *widget, GamesScoresDialog *self) {
    gchar *catcopy;
    gint idx;
    gchar *newcat;
    
    /* This seems like a bit of a hack, but since we're trying to
     * temporarily change the category it sort of makes sense. */

    catcopy = g_strdup (games_scores_get_category (self->_priv->scores));
    idx = gtk_combo_box_get_active (widget);
    newcat = g_hash_table_lookup (self->_priv->catindices,
				 GINT_TO_POINTER (idx));

    games_scores_set_category (self->_priv->scores, newcat);
    if (self->_priv->preservehilight) {
      self->_priv->preservehilight = FALSE;
    } else {
      self->_priv->hilight = 0;
    }
    games_scores_dialog_redraw (self);
    games_scores_set_category (self->_priv->scores, catcopy);

    g_free (catcopy);
  }
       
  /* This is to make sure we update ourselves when the window goes through
   * a hide/show cycle. */
  /* FIXME: We should monitor the high scores list (or get games-scores to
   * send us a signal. */
  private
  void show (GamesScoresDialog *self) { 
    const gchar *cat;
    
    cat = games_scores_get_category (self->_priv->scores);
    if (cat)
      games_scores_dialog_set_category (self, cat);
    games_scores_dialog_redraw (self);
  }

  private
  void hide (GamesScoresDialog *self) {
    self->_priv->hilight = 0;
    gtk_tree_selection_unselect_all (gtk_tree_view_get_selection (self->_priv->treeview));
  }

  init (self) {
    GtkWidget *vbox;
    GtkWidget *scroll;
    GtkWidget *listview;
    GtkTreeViewColumn *column;
    GtkCellRenderer *renderer;

    self->_priv->style = GAMES_SCORES_STYLE_PLAIN_DESCENDING;
    /* These two hashes are the reverse of each other. As an optimisation 
     * they share the same set of strings (as keys in the first case and
     * as data in the second). The first hash is responsible for 
     * deallocating the memory for the strings. These two are only
     * valid as a pair. */
    self->_priv->categories = g_hash_table_new_full (g_str_hash, g_str_equal,
						     g_free, NULL);
    self->_priv->catindices = g_hash_table_new (g_direct_hash, g_direct_equal);
    self->_priv->catcounter = 0;
    self->_priv->hilight = 0;

    gtk_dialog_set_has_separator (GTK_DIALOG (self), FALSE);
    gtk_container_set_border_width (GTK_CONTAINER (self), 5);
    gtk_box_set_spacing (GTK_BOX (GTK_DIALOG (self)->vbox), 2);

    g_signal_connect (G_OBJECT (self), "show", 
		      G_CALLBACK (games_scores_dialog_show), NULL);
    g_signal_connect (G_OBJECT (self), "hide", 
		      G_CALLBACK (games_scores_dialog_hide), NULL);

    vbox = gtk_vbox_new (FALSE, 6);
    gtk_container_set_border_width (GTK_CONTAINER (vbox), 5);
    gtk_box_pack_end (GTK_BOX (GTK_DIALOG (self)->vbox), vbox, TRUE, TRUE, 
                      0);

    scroll = gtk_scrolled_window_new (NULL, NULL);
    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scroll),
				    GTK_POLICY_AUTOMATIC,
				    GTK_POLICY_AUTOMATIC);
    gtk_widget_set_size_request (scroll, 250, 265);
    gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scroll),
					 GTK_SHADOW_ETCHED_IN);
    gtk_box_pack_end (GTK_BOX (vbox), scroll, TRUE, TRUE, 0);
    
    self->_priv->message = gtk_label_new ("");
    gtk_label_set_use_markup (GTK_LABEL (self->_priv->message), TRUE);
    gtk_label_set_justify (GTK_LABEL (self->_priv->message), 
	                   GTK_JUSTIFY_CENTER);    
    gtk_box_pack_start (GTK_BOX (vbox), self->_priv->message, FALSE, FALSE, 0);

    self->_priv->hdiv = gtk_hseparator_new ();
    gtk_box_pack_start (GTK_BOX (vbox), self->_priv->hdiv, FALSE, FALSE, 0);

    self->_priv->catbar = gtk_hbox_new (FALSE, 12);
    gtk_box_pack_start (GTK_BOX (vbox), self->_priv->catbar, FALSE, FALSE, 0);

    self->_priv->label = gtk_label_new ("");
    gtk_box_pack_start (GTK_BOX (self->_priv->catbar), self->_priv->label, 
			FALSE, FALSE, 0);	
   
    self->_priv->combo = gtk_combo_box_new_text ();
    gtk_box_pack_start (GTK_BOX (self->_priv->catbar), 
			self->_priv->combo, TRUE, TRUE, 0);

    g_signal_connect (G_OBJECT (self->_priv->combo), "changed", 
		      G_CALLBACK (games_scores_dialog_change_category), self);

    self->_priv->list = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);

    listview = gtk_tree_view_new_with_model (GTK_TREE_MODEL (self->_priv->list));
    self->_priv->treeview = GTK_TREE_VIEW (listview);
    self->_priv->cursor_handler_id = 
      g_signal_connect (G_OBJECT (self->_priv->treeview), 
			"cursor-changed", 
			G_CALLBACK (games_scores_dialog_cursor_changed), self);
    
    self->_priv->namerenderer = gtk_cell_renderer_text_new ();
    g_signal_connect (self->_priv->namerenderer, "edited", 
		      G_CALLBACK (games_scores_dialog_name_edited), self);

    self->_priv->namecolumn = gtk_tree_view_column_new_with_attributes (_("Name"),
									self->_priv->namerenderer,
									"text", 0,
									NULL);
    gtk_tree_view_append_column (GTK_TREE_VIEW (listview),
				 GTK_TREE_VIEW_COLUMN (self->_priv->namecolumn));
    renderer = gtk_cell_renderer_text_new ();
    /* Note that this assumes the default style is plain. */
    column = gtk_tree_view_column_new_with_attributes (_("Score"),
						       renderer,
						       "text", 1,
						       NULL);
    g_object_set (G_OBJECT (renderer), "xalign", 1.0, NULL);
    gtk_tree_view_append_column (GTK_TREE_VIEW (listview),
				 GTK_TREE_VIEW_COLUMN (column));
    self->_priv->column = column;
   
    gtk_container_add (GTK_CONTAINER (scroll), listview);
    
    games_scores_dialog_set_buttons (self, GAMES_SCORES_CLOSE_BUTTON);

    gtk_window_set_destroy_with_parent (GTK_WINDOW (self), TRUE);

    gtk_widget_show_all (vbox);
    gtk_widget_hide (self->_priv->hdiv);
    gtk_widget_hide (self->_priv->message);
  }

  /**
   * add_category:
   * @self: a pointer to a GamesScoresDialog
   * @key: an identifier for the category. This should also be a valid
   * score category for the gnome_score system.
   * @name: the category name
   * 
   * Adds a new category to combo box selector.
   *
   **/
  private void add_category (Games:Scores:Dialog *self, const gchar *key, 
			    const gchar *name)
  {
    gchar *k;

    k = g_strdup (key);

    g_hash_table_insert (self->_priv->categories, k, 
			 GINT_TO_POINTER (self->_priv->catcounter));
    g_hash_table_insert (self->_priv->catindices, 
			 GINT_TO_POINTER (self->_priv->catcounter),
			 k);
    self->_priv->catcounter++;
    gtk_combo_box_append_text (GTK_COMBO_BOX (self->_priv->combo), name);
  }

  /**
   * set_category:
   * @self: a pointer to a GamesScoresDialog
   * @key: the category to change to
   * 
   * Sets the category to scores dialog is displaying.
   *
   **/
  private void set_category (Games:Scores:Dialog *self, const gchar *key) {
    gint idx;

    idx = GPOINTER_TO_SIZE (g_hash_table_lookup (self->_priv->categories, 
						key));
    self->_priv->preservehilight = TRUE;
    gtk_combo_box_set_active (GTK_COMBO_BOX (self->_priv->combo), idx);
  }

  /**
   * set_style:
   * @self: a pointer to a GamesScoresDialog
   * @style: the style to use
   * 
   * Sets the style of score displayed. e.g. GAMES_SCORES_STYLE_TIME
   * displays the scores as times. Note that the order of the scores
   * is determined at the gnome_score layer but their interpretation
   * is at this layer.
   *
   **/
  private void set_style (Games:Scores:Dialog *self, GamesScoreStyle style) {
    gchar *header;

    self->_priv->style = style;
    switch (style) {
    case GAMES_SCORES_STYLE_TIME_DESCENDING:
    case GAMES_SCORES_STYLE_TIME_ASCENDING:
      header = _("Time");
      break;
    case GAMES_SCORES_STYLE_PLAIN_DESCENDING:
    case GAMES_SCORES_STYLE_PLAIN_ASCENDING:
    default:
      header = _("Score");
    }

    gtk_tree_view_column_set_title (self->_priv->column, header);
  }

  /**
   * set_category_description:
   * @self: a pointer to a GamesScoresDialog
   * @description: A description of the categories 
   * 
   * Sets the category description label. i.e. the widget to the
   * left of the category combo box. 
   *
   **/
  public void set_category_description (Games:Scores:Dialog *self, 
					const gchar *description) {
    gchar *lstr;

    lstr = g_strdup_printf ("<b>%s</b>", description);
    gtk_label_set_text (GTK_LABEL (self->_priv->label), lstr);
    gtk_label_set_use_markup (GTK_LABEL (self->_priv->label), TRUE);
    g_free(lstr);
  }

  /**
   * set_category_description:
   * @self: a pointer to a GamesScoresDialog
   * @pos: the position in the high score list to hilight. Should be in the
   * range 1 to 10.
   * 
   * Hilights an entry in the high score list. This is suitable for indicating
   * to the player where the game they just played is.
   *
   **/
  public 
  void set_hilight (Games:Scores:Dialog *self, guint pos) {
    if ((pos < 1) || (pos > GAMES_SCORES_SIGNIFICANT))
      return;

    self->_priv->hilight = pos;
    games_scores_dialog_set_hilight_private (self);
  }

  /**
   * set_message:
   * @self: a pointer to a GamesScoresDialog
   * @message: the message
   * 
   * Sets the message at the top of the dialog. Pango markup is understood.
   *
   **/
  public void set_message (Games:Scores:Dialog *self, const gchar *message) {
    if ((message == NULL) || (*message == '\0')) {
      gtk_widget_hide (self->_priv->message);
      gtk_widget_hide (self->_priv->hdiv);
    } else {
      gtk_widget_show (self->_priv->message);
      gtk_widget_show (self->_priv->hdiv);
      gtk_label_set_label (GTK_LABEL (self->_priv->message), message);
    }
  }

  /**
   * set_buttons:
   * @self: a pointer to a GamesScoresDialog
   * @buttons: An or-ed list of GamesScoresButtons
   * 
   * Changes the button sets at the buttom of the dialog
   *
   **/
  public void set_buttons (Games:Scores:Dialog *self, guint buttons) {
    /* Remove an existing buttons. */
    gtk_container_foreach (GTK_CONTAINER (GTK_DIALOG (self)->action_area),
                           (GtkCallback) (gtk_widget_destroy), NULL);

    /* The default is a single close button, suitable for the scores
       menu item. */
    if (buttons == 0)
	buttons = GAMES_SCORES_CLOSE_BUTTON;

    if (buttons & GAMES_SCORES_QUIT_BUTTON) {
	gtk_dialog_add_button (GTK_DIALOG (self), GTK_STOCK_QUIT,
	                       GTK_RESPONSE_REJECT);
        gtk_dialog_set_default_response (GTK_DIALOG (self), 
	       			         GTK_RESPONSE_REJECT);
    }

    if (buttons & GAMES_SCORES_UNDO_BUTTON) {
	gtk_dialog_add_button (GTK_DIALOG (self), GTK_STOCK_UNDO,
	                       GTK_RESPONSE_DELETE_EVENT);
        gtk_dialog_set_default_response (GTK_DIALOG (self), 
	       			         GTK_RESPONSE_DELETE_EVENT);
    }

    if (buttons & GAMES_SCORES_NEW_GAME_BUTTON) {
	gtk_dialog_add_button (GTK_DIALOG (self), _("New Game"),
	                       GTK_RESPONSE_ACCEPT);
        gtk_dialog_set_default_response (GTK_DIALOG (self), 
	       			         GTK_RESPONSE_ACCEPT);
    }

    if (buttons & GAMES_SCORES_CLOSE_BUTTON) {
	gtk_dialog_add_button (GTK_DIALOG (self), GTK_STOCK_CLOSE,
	                       GTK_RESPONSE_CLOSE);
        gtk_dialog_set_default_response (GTK_DIALOG (self), 
	       			         GTK_RESPONSE_CLOSE);
    }
  }
}
