/* Generated by GOB (v2.0.11) on Thu Jun 30 12:28:33 2005
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */


#line 54 "games-scores.gob"

/* Games Scores Dialog - Display high scores
 *
 * Copyright (c) 2005 by Callum McKenzie
 *
 */


#line 17 "games-scores.c"
#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 11

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "games-scores.h"

#include "games-scores-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 63 "games-scores.gob"

#include <gtk/gtk.h>

#line 42 "games-scores.c"

#line 67 "games-scores.gob"

#include <config.h>

#include <gnome.h>

#include <math.h>
#include <fcntl.h>
#include <unistd.h>

#include <games-scores-dialog.h>

  /* We want GamesScoresCategory to be a plain structure so it can easily
   * be initialised at compile time (to make writing a GamesScoresDescription
   * easy). However we do need some common methods. These functions
   * are here to give us our "pseudo-object". */

  void games_scores_category_free (GamesScoresCategory *cat) {
    g_free (cat->key);
    g_free (cat->name);
    g_free (cat);
  }

  GamesScoresCategory *games_scores_category_dup (GamesScoresCategory *orig) {
    GamesScoresCategory *newcat;
    
    newcat = g_new (GamesScoresCategory, 1);
    newcat->key = g_strdup (orig->key);
    newcat->name = g_strdup (orig->name);

    return newcat;
  }


#line 78 "games-scores.c"
/* self casting macros */
#define SELF(x) GAMES_SCORES(x)
#define SELF_CONST(x) GAMES_SCORES_CONST(x)
#define IS_SELF(x) GAMES_IS_SCORES(x)
#define TYPE_SELF GAMES_TYPE_SCORES
#define SELF_CLASS(x) GAMES_SCORES_CLASS(x)

#define SELF_GET_CLASS(x) GAMES_SCORES_GET_CLASS(x)

/* self typedefs */
typedef GamesScores Self;
typedef GamesScoresClass SelfClass;

/* here are local prototypes */
static void games_scores_class_init (GamesScoresClass * c) G_GNUC_UNUSED;
static void games_scores_set_dialog_categories (gchar * key, GamesScoresCategory * cat, GamesScoresDialog * dialog) G_GNUC_UNUSED;
static void games_scores_init (GamesScores * self) G_GNUC_UNUSED;

/* pointer to the class of our parent */
static GObjectClass *parent_class = NULL;

/* Short form macros */
#define self_new games_scores_new
#define self_set_category games_scores_set_category
#define self_add_score games_scores_add_score
#define self_set_dialog_categories games_scores_set_dialog_categories
#define self_show games_scores_show
GType
games_scores_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (GamesScoresClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) games_scores_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (GamesScores),
			0 /* n_preallocs */,
			(GInstanceInitFunc) games_scores_init,
			NULL
		};

		type = g_type_register_static (G_TYPE_OBJECT, "GamesScores", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((GamesScores *)g_object_new(games_scores_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static GamesScores * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static GamesScores *
GET_NEW_VARG (const char *first, ...)
{
	GamesScores *ret;
	va_list ap;
	va_start (ap, first);
	ret = (GamesScores *)g_object_new_valist (games_scores_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "Games:Scores::finalize"
	GamesScores *self G_GNUC_UNUSED = GAMES_SCORES (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
}
#undef __GOB_FUNCTION__

static void 
games_scores_class_init (GamesScoresClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Games:Scores::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) c;

	g_type_class_add_private(c,sizeof(GamesScoresPrivate));

	parent_class = g_type_class_ref (G_TYPE_OBJECT);

	g_object_class->finalize = ___finalize;
}
#undef __GOB_FUNCTION__
#line 269 "games-scores.gob"
static void 
games_scores_init (GamesScores * self G_GNUC_UNUSED)
#line 176 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::init"
	self->_priv = G_TYPE_INSTANCE_GET_PRIVATE(self,TYPE_SELF,GamesScoresPrivate);
 {
#line 269 "games-scores.gob"

    /* Most of the work is done in the _new method. */

    self->_priv->last_score_significant = FALSE;
    self->_priv->last_score_position = -1; /* FIXME: = 0? */

    self->_priv->dialog = NULL;
  
#line 190 "games-scores.c"
 }
}
#undef __GOB_FUNCTION__


/**
 * games_scores_new:
 * @description: A GamesScoresDescription structure with the information
 *               about this games scoring system. 
 *
 * Create an object to handle a set of scores. Normally you will make one
 * global object. Creating and destroying these objects is inefficient. 
 * Using multipl objects referring to the same set of scores at the same
 * time should work but is unnecessary liable to be buggy.
 **/
#line 128 "games-scores.gob"
GObject * 
games_scores_new (GamesScoresDescription * description)
#line 209 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::new"
{
#line 128 "games-scores.gob"
	
    GamesScores *self = GET_NEW;
    GamesScoresCategory *cats;
    GamesScoresCategory *dupcat;

    /* FIXME: Input sanity checks. */

    cats = self->_priv->categories;
    self->_priv->categories = g_hash_table_new_full (g_str_hash, g_str_equal,
						     g_free, 
						     games_scores_category_free);
    while (cats) {
      dupcat = games_scores_category_dup (cats);

      g_hash_table_insert (self->_priv->categories, 
				  g_strdup (cats->key),
				  dupcat);
      cats++;
    }

    self->_priv->defcat = g_strdup (description->deflt);
    self->_priv->currentcat = g_strdup (self->_priv->defcat);
    /* FIXME: Do some sanity checks on the default and the like. */
    
    self->_priv->style = description->style;

    /* Find and open the file */
    self->_priv->filename = g_build_filename (SCORESDIR,
					      description->filename, NULL);

    self->_priv->scoresfd = open (self->_priv->filename, O_RDWR);
    /* FIXME: We don't have a finaliser yet to close the fd again. */


    /*    self->_priv->lock->l_type = F_RDLCK;
    self->_priv->l_whence = SEEK_SET;
    self->_priv->l_start = 0; 
    self->_priv->l_len = 0; *//* All of it */

    return self;
  }}
#line 255 "games-scores.c"
#undef __GOB_FUNCTION__

/**
 * games_scores_set_category:
 * @scores: A scores object.
 * @category: A string identifying the category to use (the key in
 *            the GamesScoresCategory structure).
 *
 * This function sets the scores category to use. e.g. whether we are playing
 * on hard, medium or easy. It should be used at the time that the game
 * itself switches between difficulty levels. The category determines where
 * scores are to be stored and what the default score display is when the
 * dialog is requested.
 *
 **/
#line 183 "games-scores.gob"
void 
games_scores_set_category (GamesScores * self, gchar * category)
#line 274 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::set_category"
{
#line 183 "games-scores.gob"
	

    g_return_if_fail (self != NULL);

    if (category == NULL)
      category = self->_priv->defcat;

    if (self->_priv->currentcat)
      g_free (self->_priv->currentcat);

    self->_priv->currentcat = g_strdup (category);
      
    if (self->_priv->dialog != NULL)
      games_scores_dialog_set_category (GAMES_SCORES_DIALOG (self->_priv->dialog),
					category);

    /* FIXME: Check validity of category (Null, the same as current, 
     * is actually a category) then just set it in the structure. */
  }}
#line 298 "games-scores.c"
#undef __GOB_FUNCTION__

/**
 * games_scores_add_score:
 * @scores: A scores object.
 * @score: A GamesScore, please use the macros to convert a score to the
 *         gpointer format.
 *
 * Add a score to the set of scores. Retention of anything but the
 * top-ten scores is undefined. It returns a boolean indicating whether
 * the score is a top-ten one or not.
 **/
#line 214 "games-scores.gob"
gboolean 
games_scores_add_score (GamesScore * self, GamesScore score)
#line 314 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::add_score"
{
#line 214 "games-scores.gob"
	
    /* FIXME: Fill in. */
    return FALSE;
  }}
#line 323 "games-scores.c"
#undef __GOB_FUNCTION__

#line 219 "games-scores.gob"
static void 
games_scores_set_dialog_categories (gchar * key, GamesScoresCategory * cat, GamesScoresDialog * dialog)
#line 329 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::set_dialog_categories"
{
#line 222 "games-scores.gob"
	
      games_scores_dialog_add_category (dialog, key, cat->name);
    }}
#line 337 "games-scores.c"
#undef __GOB_FUNCTION__

/**
 * games_scores_show:
 * @scores: A scores object.
 * @hilight: Whether or not to hilight the last high score set (if
 *           it was a top-ten score).
 *
 * The basic function for showing a high scores dialog. All the details
 * are taken care of for you, you merely have to decide on whether this
 * is a user interested in the historic high scores or if it is a report 
 * on the last game played.
 **/
#line 237 "games-scores.gob"
void 
games_scores_show (GamesScores * self, gboolean hilight)
#line 354 "games-scores.c"
{
#define __GOB_FUNCTION__ "Games:Scores::show"
{
#line 237 "games-scores.gob"
	
    GtkWidget *dialog;
    GamesScoresCategory *cats;
    
    if (self->_priv->dialog == NULL) {
      /* FIXME: The title is a problem. */
      dialog = games_scores_dialog_new (NULL, "This title is wrong");

      g_hash_table_foreach (self->_priv->categories, 
			    (GHFunc) games_scores_set_dialog_categories,
			    dialog);

      /* FIXME: Also fill in the buttons and the message and the like. 
       * This may have to be done below. */

      games_scores_dialog_set_category (GAMES_SCORES_DIALOG (dialog),
					self->_priv->currentcat);

      self->_priv->dialog = dialog;
    } else {
      /* FIXME: Probably should move this beyond the code that
       * sets the hilight and the like. */
      gtk_window_present (GTK_WINDOW (self->_priv->dialog));
    }
    
    if (hilight) {
      games_scores_dialog_set_hilight (GAMES_SCORES_DIALOG (self->_priv->dialog),
				       self->_priv->last_score_position);
    }

  }}
#line 390 "games-scores.c"
#undef __GOB_FUNCTION__

